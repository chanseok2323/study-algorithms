## 배열
 - 배열을 선언할 때, 배열의 크기를 알려주면, 운영체제는 해당 배열의 크기 만큼 연속적으로 비어있는 곳을 찾아서 할당
   - 운영체제는 배열의 시작 주소만 기억, 인덱스를 통해서 배열을 찾을 때, 배열의 시작 주소부터 인덱스 만큼 떨어진 데이터를 가져옴
 - 배열의 참조 성능은 좋지만, 데이터의 삽입, 삭제 연산은 좋지 않음
    - 해당 배열의 중간에 값을 삽입 하기 위해서는 해당 인덱스에 부터 그 뒤에 있는 데이터를 전부 뒤로 밀려나기 때문에 오버헤드 발생
    - 프로그래머가 배열 선언 후 해당 배열보다, 더 큰 데이터를 넣을려고 할 때, 운영체제는 해당 배열 크기의 연속적으로 연결되어 있는 메모리 공간을 찾은 후 기존의 데이터를 전부 복사
        - 배열의 크기 예측이 힘들기 때문에 메모리 낭비가 발생 할 수 있음
 - 인덱스 참조는 배열의 크기와 상관 없이 가져오기 때문에 **O(1)** 의 성능을 가짐
 - 삽입 삭제 시, **O(n)** 의 성능을 가짐
 - 자바스크립트의 배열은 연속적 또는 불연속적으로 할당 가능하며, 주로 불연속적으로 할당

## 연결 리스트(Linked List)
 - 저장하려는 데이터들을 메모리 공간에 분산해서 할당하고, 이 데이터들을 서로 연결
 - 힙 영역에 런타임 시, 불연속적으로 할당
 - 첫 노드의 주소만 알고 있으면 다른 모든 노드에 접근 가능
 - 데이터의 삽입 삭제가 쉬움
    - 빈 메모리 공간에 데이터를 생성하고 연결만 해주면 됨, 삭제도 동일
 - 연결리스트는 데이터들이 전부 떨어져 있기 대문에 바로 접근 할 수 없음
 - 데이터 참조는 **O(n)** 의 성능을 가짐
 - 삽입, 삭제 시 **O(n)** 의 성능을 가짐
    - 삽입 및 삭제하려는 노드를 계속 타고 가야하기 때문

## 스택(Stack)
 - FILO(First In Last Out)

## 큐(Queue)
 - FIFO(First In First Out)

## 덱(Deque)
 - 데이터의 삽입과 제거를 head 와 tail 두 군데서 자유롭게 할 수 있는 자료구조